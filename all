#Зайдите на страницу Википедии, посвящённую Международному индексу счастья,
#выберите из таблицы 2012 Международный индекс счастья любые 5 стран и любые 3 показателя и создайте структурированный массив happy,
#такой, в котором есть поле «название страны» и поля для трёх выбранных показателей. Выберите подходящий тип для каждого поля (показателя)
#в массиве и учтите это при создание структурированного массива. Выведите полученный массив на экран.

import numpy as np
data = [
    ('Germany', 6.909, 1.256, 0.240),
    ('United Kingdom', 6.857, 1.317, 0.300),
    ('United States', 6.814, 1.399, 0.200),
    ('Japan', 6.778, 1.271, 0.250),
    ('China', 5.284, 0.579, 0.290)
]
happy = np.array(data, dtype=[('country', 'U20'), ('happy_index', 'f4'), ('gdp_per_capita', 'f4'), ('generosity', 'f4')])
print (happy)

                                                                               ####################

#Сконвертируйте полученный в предыдущей задаче структурированный массив в обычный список и выведите на экран его второй элемент.
import numpy as np
data = [
    ('Germany', 6.909, 1.256, 0.240),
    ('United Kingdom', 6.857, 1.317, 0.300),
    ('United States', 6.814, 1.399, 0.200),
    ('Japan', 6.778, 1.271, 0.250),
    ('China', 5.284, 0.579, 0.290)
]
happy = np.array(data, dtype=[('country', 'U20'), ('happy_index', 'f4'), ('gdp_per_capita', 'f4'), ('generosity', 'f4')])
list_happy = happy.tolist()
list_happy[1]


                                                                               ####################


#Функция build_array(), которая принимает на вход размерность квадратной матрицы
#(двумерного массива, в котором число строк и число столбцов совпадают) и создаёт единичную матрицу E (массив)
#соответствующей размерности. Использовать готовую функцию np.eye() нельзя, можно использовать циклы и условные конструкции.
import numpy as np

def build_array(n):
    E = np.zeros((n, n))
    for i in range(n):
        E[i, i] = 1
    return E
print(build_array(4))

                                                                               ####################

#Функция my_reshape(), которая принимает на вход массив и его новую размерность (пару чисел), и:
#если указанные измерения корректны, то возвращает массив новой размерности;
#если указанные измерения некорректны, то возвращает пустой массив
#(пример: из массива 2×5 нельзя сделать новый массив 4×3, потому что в старом массиве 10 элементов, а в новом – 12).

import numpy as np

def my_reshape(arr, new_shape):
    if arr.size == np.prod(new_shape):
        return arr.reshape(new_shape)
    else:
        return np.array([])
A = np.array([[2, 4, 6], [4, 8, 10]])
print(my_reshape(A, (6, 1)))
print(my_reshape(A, (4, 2)))

                                                                               ####################

#Создайте (любым способом) маленький датафрейм, состоящий из двух столбцов:
#fh_type: тип страны;
#count: число стран данного типа.
#Постройте, используя полученный датафрейм, столбиковую диаграмму (barplot),
#опираясь на эту документацию. Чтобы увидеть график явно, прямо в текущем ноутбуке,
#допишите в начале ячейки с кодом для графика следующую строку %matplotlib inline

data = {'fh_type': ['north', 'south', 'middle'],
'count': [20, 30, 100]}
df = pd.DataFrame(data)
%matplotlib inline
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
plt.bar(df['fh_type'], df['count'], color='skyblue')
plt.title('Распределение стран по типам')
plt.xlabel('Тип страны')
plt.ylabel('Количество стран')
plt.grid(axis='y', linestyle='--', alpha=0.7)
for index, value in enumerate(df['count']):
    plt.text(index, value + 1, str(value), ha='center')


plt.show()
